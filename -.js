// Generated by the V compiler


var $global = (new Function("return this"))();
function $ref(value) { if (value instanceof $ref) { return value; } this.val = value; } 
$ref.prototype.valueOf = function() { return this.val; } 
const $os = require("os");
const $process = process;
function checkDefine(key) {
	if (globalThis.hasOwnProperty(key)) { return !!globalThis[key]; } return false;
}
function Array_int_contains(a,v) {
	for (let i = 0; i < a.len; ++i) {
		if (vEq(a.arr.get(new int(i)),v)) {
			return new bool(true);
		}
	}
	return new bool(false);
}

function compare_RepIndex_by_idx(a,b) {
	if (a.val.idx.valueOf() < b.val.idx.valueOf()) return -1;
	else return 1;
}

// V_COMMIT_HASH 108644d
// V_CURRENT_COMMIT_HASH 632f473

let wasmExportObject;
const loadRoutine = async () => {
}
// https://www.npmjs.com/package/fast-deep-equal - 3/3/2021
const envHasBigInt64Array = typeof BigInt64Array !== 'undefined';
function vEq(a, b) {
	if (a === b) return true;

	if (a && b && typeof a == 'object' && typeof b == 'object') {
		if (a.constructor !== b.constructor) return false;
		// we want to convert all V types to JS for comparison.
		if ('$toJS' in a)
			a = a.$toJS();

		if ('$toJS' in b)
			b = b.$toJS();

		var length, i, keys;
		if (Array.isArray(a)) {
			length = a.length;
			if (length != b.length) return false;
			for (i = length; i-- !== 0;)
				if (!vEq(a[i], b[i])) return false;
			return true;
		}


		if ((a instanceof Map) && (b instanceof Map)) {
			if (a.size !== b.size) return false;
			for (i of a.entries())
				if (!b.has(i[0])) return false;
			for (i of a.entries())
				if (!vEq(i[1], b.get(i[0]))) return false;
			return true;
		}

		if ((a instanceof Set) && (b instanceof Set)) {
			if (a.size !== b.size) return false;
			for (i of a.entries())
				if (!b.has(i[0])) return false;
			return true;
		}

		if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
			length = a.length;
			if (length != b.length) return false;
			for (i = length; i-- !== 0;)
				if (a[i] !== b[i]) return false;
			return true;
		}


		if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
		if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
		if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

		keys = Object.keys(a);
		length = keys.length;
		if (length !== Object.keys(b).length) return false;

		for (i = length; i-- !== 0;)
			if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

		for (i = length; i-- !== 0;) {
			var key = keys[i];

			if (!vEq(a[key], b[key])) return false;
		}

		return true;
	}

	// true if both NaN, false otherwise
	return a!==a && b!==b;
};

function $sortComparator(a, b)
{
a = a.$toJS();
b = b.$toJS();
if (a > b) return 1;
if (a < b) return -1;
return 0;


}

/** @namespace strings */
function strings__Builder(val) { return val;  }
/**
 * @function
 * @param {int} initial_size
 * @returns {strings__Builder}
*/
function strings__new_builder(initial_size) {return new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
}

/**
 * @function
 * @param {byte} data
 * @returns {void}
*/
function strings__Builder_write_b(b, data) {b = new $ref(b)
array_push(b.val,data,false);
}

/**
 * @function
 * @param {Array_byte} data
 * @returns {int}
*/
function strings__Builder_write(b, data) {b = new $ref(b)
if ((new bool(data.len.valueOf() == new int(0).valueOf())).valueOf()) {
const _tmp1 = new Option({});
_tmp1.data = new int(0)
return _tmp1;}
array_push(b.val,data.arr.arr,true);
const _tmp2 = new Option({});
_tmp2.data = data.len
return _tmp2;}

/**
 * @function
 * @param {int} n
 * @returns {byte}
*/
function strings__Builder_byte_at(b, n) {b = new $ref(b)
{
	return b.valueOf().arr.get(new int(n.valueOf()));
}

}

/**
 * @function
 * @param {string} s
 * @returns {void}
*/
function strings__Builder_write_string(b, s) {b = new $ref(b)
if ((new bool(s.len.valueOf() == new int(0).valueOf())).valueOf()) {
return;
}
for (const c of s.str.split('').map(c => new byte(c))) {
array_push(b.val,c,false);
}

}

/**
 * @function
 * @param {string} s
 * @returns {void}
*/
function strings__Builder_writeln(b, s) {b = new $ref(b)
if ((new bool(s.len.valueOf() > new int(0).valueOf())).valueOf()) {
strings__Builder_write_string(b.val,s);
}
array_push(b.val,new int(10),false);
}

/**
 * @function
 * @returns {string}
*/
function strings__Builder_str(b) {b = new $ref(b)
/** @type {string} */
const s = new string(new string(""));
for (const c of b.val.arr.arr)
s.str += String.fromCharCode(+c)
array_trim(b.val,new int(0));
return s;
}

/**
 * @function
 * @param {int} n
 * @returns {string}
*/
function strings__Builder_cut_last(b, n) {b = new $ref(b)
/** @type {int} */
const cut_pos = new int(new int( b.val.len.valueOf() - n.valueOf()));
/** @type {strings__Builder} */
const x = array_slice(b.valueOf(),cut_pos, b.valueOf().len);
/** @type {string} */
const res = new string(array_bytestr(x,));
array_trim(b.val,cut_pos);
return res;
}

/**
 * @function
 * @param {int} pos
 * @returns {void}
*/
function strings__Builder_go_back_to(b, pos) {b = new $ref(b)
array_trim(b.val,pos);
}

/**
 * @function
 * @param {int} n
 * @returns {void}
*/
function strings__Builder_go_back(b, n) {b = new $ref(b)
array_trim(b.val,new int( b.val.len.valueOf() - n.valueOf()));
}

/**
 * @function
 * @param {int} pos
 * @returns {string}
*/
function strings__Builder_cut_to(b, pos) {b = new $ref(b)
if ((new bool(pos.valueOf() > b.val.len.valueOf())).valueOf()) {
return new string("");
}
return strings__Builder_cut_last(b.val,new int( b.val.len.valueOf() - pos.valueOf()));
}

/**
 * @function
 * @param {Array_rune} runes
 * @returns {void}
*/
function strings__Builder_write_runes(b, runes) {b = new $ref(b)
for (const r of runes) {
/** @type {string} */
const res = new string(new string(r.toString()));
res.str = String.fromCharCode(r.val)
array_push(b.val,string_bytes(res,).arr.arr,true);
}

}

/**
 * @function
 * @param {int} n
 * @returns {string}
*/
function strings__Builder_after(b, n) {b = new $ref(b)
if ((new bool(n.valueOf() >= b.val.len.valueOf())).valueOf()) {
return new string("");
}
/** @type {array} */
const x = array_slice(b.val,n, b.val.len);
return array_bytestr(x,);
}

/**
 * @function
 * @param {int} n
 * @returns {string}
*/
function strings__Builder_last_n(b, n) {b = new $ref(b)
if ((new bool(n.valueOf() >= b.val.len.valueOf())).valueOf()) {
return new string("");
}
/** @type {array} */
const x = array_slice(b.val,new int( b.val.len.valueOf() - n.valueOf()), b.val.len);
return array_bytestr(x,);
}

/** @namespace strings */
/**
 * @function
 * @param {string} a
 * @param {string} b
 * @returns {int}
*/
function strings__levenshtein_distance(a, b) {/** @type {Array_int} */
let f = array_repeat(new array(new array_buffer({arr: [new int(new int(0))], len: new int(1), cap: new int(1)})),new int( b.len.valueOf() + new int(1).valueOf()));
for (let j = new int(0); j < f.len; j = new int(j + 1)) {
/** @type {int} */
f.arr.set(new int(j.valueOf()),new int(j));
}

for (const ca of a.str.split('').map(c => new byte(c))) {
/** @type {int} */
let j = new int(new int(1));
/** @type {int} */
let fj1 = new int(f.arr.get(new int(new int(0).valueOf())));
f.arr.get(new int(new int(0).valueOf())).val ++;
for (const cb of b.str.split('').map(c => new byte(c))) {
/** @type {int} */
let mn = new int(((new bool(new int( f.arr.get(new int(j.valueOf())).valueOf() + new int(1).valueOf()).valueOf() <= new int( f.arr.get(new int(new int( j.valueOf() - new int(1).valueOf()).valueOf())).valueOf() + new int(1).valueOf()).valueOf())).valueOf() ? new int( f.arr.get(new int(j.valueOf())).valueOf() + new int(1).valueOf()) : new int( f.arr.get(new int(new int( j.valueOf() - new int(1).valueOf()).valueOf())).valueOf() + new int(1).valueOf())));
if ((new bool(cb.valueOf() != ca.valueOf())).valueOf()) {
/** @type {int} */
mn = new int(((new bool(mn.valueOf() <= new int( fj1.valueOf() + new int(1).valueOf()).valueOf())).valueOf() ? mn : new int( fj1.valueOf() + new int(1).valueOf())));
} else {
/** @type {int} */
mn = new int(((new bool(mn.valueOf() <= fj1.valueOf())).valueOf() ? mn : fj1));
}
/** @type {int} */
fj1 = new int(f.arr.get(new int(j.valueOf())));
/** @type {int} */
f.arr.set(new int(j.valueOf()),new int(mn));
j.val ++;
}

}

return f.arr.get(new int(new int( f.len.valueOf() - new int(1).valueOf()).valueOf()));
}

/**
 * @function
 * @param {string} a
 * @param {string} b
 * @returns {f32}
*/
function strings__levenshtein_distance_percentage(a, b) {/** @type {int} */
const d = new int(strings__levenshtein_distance(a, b));
/** @type {int} */
const l = new int(((new bool(a.len.valueOf() >= b.len.valueOf())).valueOf() ? a.len : b.len));
return new f32( (new f32( new f32(1.00).valueOf() - new f32( new f32(d).valueOf() / new f32(l).valueOf()).valueOf())).valueOf() * new f32(100.00).valueOf());
}

/**
 * @function
 * @param {string} s1
 * @param {string} s2
 * @returns {f32}
*/
function strings__dice_coefficient(s1, s2) {if ((new bool( new bool(s1.len.valueOf() == new int(0).valueOf()).valueOf() || new bool(s2.len.valueOf() == new int(0).valueOf()).valueOf())).valueOf()) {
return new f32(0.0);
}
if ((new bool(s1.valueOf() == s2.valueOf())).valueOf()) {
return new f32(1.0);
}
if ((new bool( new bool(s1.len.valueOf() < new int(2).valueOf()).valueOf() || new bool(s2.len.valueOf() < new int(2).valueOf()).valueOf())).valueOf()) {
return new f32(0.0);
}
/** @type {string} */
const a = new string(((new bool(s1.len.valueOf() > s2.len.valueOf())).valueOf() ? s1 : s2));
/** @type {string} */
const b = new string(((new bool(a.valueOf() == s1.valueOf())).valueOf() ? s2 : s1));
/** @type {Map_string_int} */
let first_bigrams = new map(
	new Map());
for (let i = new int(0); i < new int( a.len.valueOf() - new int(1).valueOf()); i = new int(i + 1)) {
/** @type {string} */
const bigram = new string(string_slice(a,i, new int_literal( i.valueOf() + new int(2).valueOf())));
/** @type {int} */
const q = new int(((first_bigrams.map.has(bigram.$toJS())).valueOf() ? new int( first_bigrams.map.get(bigram.$toJS()).valueOf() + new int(1).valueOf()) : new int(1)));
/** @type {int} */
first_bigrams.map.set(bigram.$toJS(),new int(q));
}

/** @type {int} */
let intersection_size = new int(new int(0));
for (let i = new int(0); i < new int( b.len.valueOf() - new int(1).valueOf()); i = new int(i + 1)) {
/** @type {string} */
const bigram = new string(string_slice(b,i, new int_literal( i.valueOf() + new int(2).valueOf())));
/** @type {int} */
const count = new int(((first_bigrams.map.has(bigram.$toJS())).valueOf() ? first_bigrams.map.get(bigram.$toJS()) : new int(0)));
if ((new bool(count.valueOf() > new int(0).valueOf())).valueOf()) {
/** @type {int} */
first_bigrams.map.set(bigram.$toJS(),new int(new int( count.valueOf() - new int(1).valueOf())));
intersection_size.val ++;
}
}

return new f32( (new f32( new f32(2.0).valueOf() * new f32(intersection_size).valueOf())).valueOf() / (new f32( new f32( new f32(a.len).valueOf() + new f32(b.len).valueOf()).valueOf() - new int(2).valueOf())).valueOf());
}

/** @namespace strings */
/**
 * @function
 * @param {byte} c
 * @param {int} n
 * @returns {string}
*/
function strings__repeat(c, n) {if ((new bool(n.valueOf() <= new int(0).valueOf())).valueOf()) {
return new string("");
}
/** @type {Array_byte} */
const arr = array_repeat(new array(new array_buffer({arr: [new byte(c)], len: new int(1), cap: new int(1)})),n);
return array_bytestr(arr,);
}

/**
 * @function
 * @param {string} s
 * @param {int} n
 * @returns {string}
*/
function strings__repeat_string(s, n) {/** @type {string} */
const res = new string(new string(""));
res.str = s.str.repeat(n.valueOf())
return res;
}

/** @namespace strings */
/** @namespace builtin */
	function i8(val = new Number(0)) { this.val = Number(val) & 0xffffffff }
	i8.prototype = {
		val: new Number(0),
		valueOf() { return Number(this.val) },
		toString() { return this.valueOf().toString() },
		$toJS() { return +this }, 
	};

	function i8__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function i16(val = new Number(0)) { this.val = Number(val) & 0xffffffff }
	i16.prototype = {
		val: new Number(0),
		valueOf() { return Number(this.val) },
		toString() { return this.valueOf().toString() },
		$toJS() { return +this }, 
	};

	function i16__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function int(val = new Number(0)) { this.val = Number(val) & 0xffffffff }
	int.prototype = {
		val: new Number(0),
		valueOf() { return Number(this.val) },
		toString() { return this.valueOf().toString() },
		$toJS() { return +this }, 
	};

	function int__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function i64(val = BigInt(0)) { this.val = BigInt.asIntN(64,BigInt(val)) }
	i64.prototype = {
		val: BigInt(0),
		valueOf() { return this.val },
		toString() { return this.val.toString() },
		$toJS() { return this.val }, 
	};

	function i64__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function byte(val = new Number(0)) { if (typeof(val) == "string") { this.val = val.charCodeAt() } else if (val instanceof string) { this.val = val.str.charCodeAt(); } else { this.val =  val | 0 } }
	byte.prototype = {
		val: new Number(0),
		valueOf() { return this.val | 0 },
		toString() { return new string(this.val + "") },
		$toJS() { return +this }, 
	};

	function byte__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function u16(val = new Number(0)) { this.val = Number(val) & 0xffffffff }
	u16.prototype = {
		val: new Number(0),
		valueOf() { return Number(this.val) },
		toString() { return this.valueOf().toString() },
		$toJS() { return +this }, 
	};

	function u16__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function u32(val = new Number(0)) { this.val = Number(val) & 0xffffffff }
	u32.prototype = {
		val: new Number(0),
		valueOf() { return Number(this.val) },
		toString() { return this.valueOf().toString() },
		$toJS() { return +this }, 
	};

	function u32__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function u64(val = BigInt(0)) { this.val = BigInt.asUintN(64,BigInt(val)) }
	u64.prototype = {
		val: BigInt(0),
		valueOf() { return this.val },
		toString() { return this.val.toString() },
		$toJS() { return this.val }, 
	};

	function u64__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function f32(val = new Number(0)) { this.val = Number(val) }
	f32.prototype = {
		val: new Number(0),
		valueOf() { return this.val },
		toString() { return this.val.toString() },
		$toJS() { return +this }, 
	};

	function f32__eq(self,other) { return self.val === other.val; } 
	function f64(val = new Number(0)) { this.val = Number(val) }
	f64.prototype = {
		val: new Number(0),
		valueOf() { return this.val },
		toString() { return this.val.toString() },
		$toJS() { return +this }, 
	};

	function f64__eq(self,other) { return self.val === other.val; } 
	function int_literal(val = new Number(0)) { this.val = Number(val) & 0xffffffff }
	int_literal.prototype = {
		val: new Number(0),
		valueOf() { return Number(this.val) },
		toString() { return this.valueOf().toString() },
		$toJS() { return +this }, 
	};

	function int_literal__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function float_literal(val = new Number(0)) { this.val = Number(val) }
	float_literal.prototype = {
		val: new Number(0),
		valueOf() { return this.val },
		toString() { return this.val.toString() },
		$toJS() { return +this }, 
	};

	function float_literal__eq(self,other) { return self.val === other.val; } 
	function bool(val = new Boolean(false)) { this.val = val instanceof bool ? val.val : +val !== 0 }
	bool.prototype = {
		val: new Boolean(false),
		valueOf() { return this.val },
		toString() { return this.val.toString() },
		$toJS() { return +this != 0 }, 
	};

	function bool__eq(self,other) { return new bool(self.val === other.valueOf()); } 
	function string(str = new String("")) { this.str = str.toString(); this.len = this.str.length }
	string.prototype = {
		str: new String(""),
		valueOf() { return this.str },
		toString() { return this.str },
		$toJS() { return this.str }, 
	};

	function string__eq(self,other) { return new bool(self.str === other.str); } 
	function map(map = new map(new Map())) { this.map = map }
	map.prototype = {
		map: new map(new Map()),
		valueOf() { return this },
		toString() { return this.map.toString() },
		$toJS() { return this.map }, 
	};

	function map__eq(self,other) { return new bool(vEq(self, other)); } 
	function array(arr = new array_buffer({})) { this.arr = arr
if (arr.index_start.val != 0 || arr.has_slice.val) { v_makeSlice(this); }  }
	array.prototype = {
		arr: new array_buffer({}),
		valueOf() { return this },
		toString() { return JSON.stringify(this.arr.map(it => it.valueOf())) },
		$toJS() { return this.arr }, 
	};

	function array__eq(self,other) { return new bool(vEq(self, other)); } 
	function rune(val = new Number(0)) { val = val.valueOf(); if (typeof val == "string") {this.val = val.charCodeAt();}  else if (val instanceof string) { this.val = val.str.charCodeAt(); } else { this.val =  val | 0 } }
	rune.prototype = {
		val: new Number(0),
		valueOf() { return this.val | 0 },
		toString() { return new string(this.val + "") },
		$toJS() { return +this }, 
	};

	function rune__eq(self,other) { return new bool(self.valueOf() === other.valueOf()); } 
	function any(any = null) { this.val = any }
	any.prototype = {
		any: null,
		valueOf() { return this.val },
		toString() { return "&" + this.val },
		$toJS() { return this.val.$toJS() }, 
	};

	function any__eq(self,other) { return new bool(self == other); } 
Object.defineProperty(array.prototype,"len", { get: function() {return new int(this.arr.arr.length);}, set: function(l) { this.arr.arr.length = l.valueOf(); } }); 
Object.defineProperty(map.prototype,"len", { get: function() {return new int(this.map.size);}, set: function(l) { this.map.size = l.valueOf(); } }); 
Object.defineProperty(array.prototype,"length", { get: function() {return new int(this.arr.arr.length);}, set: function(l) { this.arr.arr.length = l.valueOf(); } }); 
/**
 * @constructor
 * @param {{arr?: JS__Array, index_start?: int, len?: int, cap?: int, has_slice?: bool}} init
*/
function array_buffer({ arr = new Array(), index_start = new int(0), len = new int(0), cap = new int(0), has_slice = new bool(false) }) {
	this.arr = arr
	this.index_start = index_start
	this.len = len
	this.cap = cap
	this.has_slice = has_slice
};
array_buffer.prototype = {
	toString() {
		return `array_buffer { arr: ${this["arr"].toString()} , index_start: ${this["index_start"].toString()} , len: ${this["len"].toString()} , cap: ${this["cap"].toString()} , has_slice: ${this["has_slice"].toString()} }`
	},
	/** @type {JS__Array} */
	arr: new Array(),
	/** @type {int} */
	index_start: new int(0),
	/** @type {int} */
	len: new int(0),
	/** @type {int} */
	cap: new int(0),
	/** @type {bool} */
	has_slice: new bool(false),
	$toJS() { return this; }
	};

/**
 * @function
 * @returns {void}
*/
function array_buffer_make_copy(a) {a = new $ref(a)
if ((new bool( new bool(a.val.index_start.valueOf() != new int(0).valueOf()).valueOf() || a.val.has_slice.valueOf())).valueOf()) {
/** @type {JS__Array} */
let new_arr = makeEmtpyJSArray();
for (let i = new int(0); i < a.val.len; i = new int(i + 1)) {
new_arr.push(a.val.get(i))
/** @type {int} */
let x = new int(i);
/** @type {int} */
x = new int(x);
}

/** @type {JS__Array} */
new_arr = new_arr;
a.val.arr = new_arr
a.val.index_start = new int(0)
a.val.has_slice = new bool(false)
}
}

array_buffer.prototype.make_copy = function() { return array_buffer_make_copy(this) }
/**
 * @function
 * @param {int} ix
 * @returns {any}
*/
function array_buffer_get(a, ix) {/** @type {any} */
let res = new any(new int(0));
res = a.arr[a.index_start.val + ix.val];
return res;
}

/**
 * @function
 * @param {int} ix
 * @param {any} val
 * @returns {void}
*/
function array_buffer_set(a, ix, val) {a = new $ref(a)
a.val.arr[a.val.index_start.valueOf() + ix.valueOf()] = val;
}

array_buffer.prototype.get = function(ix) { return array_buffer_get(this,ix);}
array_buffer.prototype.set = function(ix,val) { array_buffer_set(this,ix,val); }
/**
 * @function
 * @param {array} arr
 * @param {anon_fn_voidptr_voidptr__int} comparator
 * @returns {void}
*/
function v_sort(arr, comparator) {arr = new $ref(arr)
/** @type {bool} */
let need_iter = new bool(new bool(true));
while (+need_iter) {
/** @type {bool} */
need_iter = new bool(new bool(false));
for (let i = new int(new int(1)); +new bool(i.valueOf() < arr.val.len.valueOf()); i.val ++) {
if ((new bool(comparator(arr.valueOf().arr.get(new int(i.valueOf())), arr.valueOf().arr.get(new int(new int( i.valueOf() - new int(1).valueOf()).valueOf()))).valueOf() != new int(1).valueOf())).valueOf()) {
let tmp = arr.valueOf().arr.get(new int(i.valueOf())); arr.valueOf().arr.set(new int(i.valueOf()),arr.valueOf().arr.get(new int(new int( i.valueOf() - new int(1).valueOf()).valueOf()))); arr.valueOf().arr.set(new int(new int( i.valueOf() - new int(1).valueOf()).valueOf()),tmp); need_iter = new bool(new bool(true)); }
}

}

}

/**
 * @function
 * @param {int} index
 * @returns {void}
*/
function array_trim(a, index) {a = new $ref(a)
if ((new bool(index.valueOf() < a.val.len.valueOf())).valueOf()) {
/** @type {int} */
a.val.len = new int(index);
}
}

function flatIntoArray(target, source, sourceLength, targetIndex, depth) {
"use strict";

for (var sourceIndex = 0; sourceIndex < sourceLength; ++sourceIndex) {
if (sourceIndex in source) {
var element = source[sourceIndex];
if (depth > 0 && Array.isArray(element))
targetIndex = flatIntoArray(target, element, element.length, targetIndex, depth - 1);
else {
target[targetIndex] = element;
++targetIndex;
}
}
}
return targetIndex;
}
function flatArray(target,depth) {
var array = target
var length = array.length;
var depthNum = 1;

if (depth !== undefined)
depthNum = +depth

var result = []

flatIntoArray(result, array, length, 0, depthNum);
return result;
}
/* [unsafe] */
/**
 * @function
 * @param {int} count
 * @param {int} depth
 * @returns {array}
*/
function array_repeat_to_depth(a, count, depth) {if ((new bool(count.valueOf() < new int(0).valueOf())).valueOf()) {
builtin__panic (new string(`array.repeat: count is negative: ${int_str(count)}`));
}
/** @type {array} */
let arr = empty_array();
if ((new bool(a.len.valueOf() > new int(0).valueOf())).valueOf()) {
for (let _tmp3 = new int(0); _tmp3 < count; _tmp3 = new int(_tmp3 + 1)) {
for (let i = new int(0); i < a.len; i = new int(i + 1)) {
if ((new bool(depth.valueOf() > new int(0).valueOf())).valueOf()) {
} else {
array_push(arr,array_buffer_get(a.arr,i));
}
}

}

}
return arr;
}

/**
 * @function
 * @returns {any}
*/
function array_last(a) {/** @type {any} */
let res = new any(new int(0));
res = a.arr.get(new int(a.len-1));
return res;
}

/**
 * @function
 * @param {int} ix
 * @returns {any}
*/
function array_get(a, ix) {/** @type {any} */
let result = new any(new int(0));
result = a.arr.get(ix)
return result;
}

/**
 * @function
 * @param {int} count
 * @returns {array}
*/
function array_repeat(a, count) {{
	return array_repeat_to_depth(a,count, new int(0));
}

}

function makeEmptyArray() { return new array(new array_buffer({})); }
function makeEmtpyJSArray() { return new Array(); }
/**
 * @function
 * @returns {array}
*/
function empty_array() {return makeEmptyArray();
}

/**
 * @function
 * @param {int} i
 * @returns {void}
*/
function array_set_len(a, i) {a = new $ref(a)
a.arr.arr.length=i
}

/**
 * @function
 * @param {any} compare
 * @returns {void}
*/
function array_sort_with_compare(a, compare) {a = new $ref(a)
v_sort(a, compare);
}

/**
 * @function
 * @param {any} compare
 * @returns {void}
*/
function array_sort_with_compare_old(a, compare) {a = new $ref(a)
a.val.arr.arr.sort(compare)
}

/**
 * @function
 * @returns {void}
*/
function array_sort(a) {a = new $ref(a)
a.val.arr.arr.sort($sortComparator)
}

/**
 * @function
 * @param {string} v
 * @returns {int}
*/
function array_index(a, v) {for (let i = new int(0); i < a.len; i = new int(i + 1)) {
if (a.arr.get(i).toString() == v.toString())
{
	return i;
}

}

return new int(-1);
}

/**
 * @function
 * @param {int} start
 * @param {int} end
 * @returns {array}
*/
function array_slice(a, start, end) {/** @type {array} */
let result = a;
let slice = a.arr.arr.slice(start,end)
result = new array(new array_buffer({arr: a.arr.arr, len: new int(slice.length),cap: new int(slice.length),index_start: new int(start),has_slice: new bool(true)}))
a.arr.has_slice = true
return result;
}

/**
 * @function
 * @param {int} i
 * @param {any} val
 * @returns {void}
*/
function array_insert(a, i, val) {a = new $ref(a)
a.val.arr.make_copy()
a.val.arr.arr.splice(i,0,val)
}

/**
 * @function
 * @param {int} i
 * @param {any} val
 * @param {int} size
 * @returns {void}
*/
function array_insert_many(a, i, val, size) {a = new $ref(a)
a.val.arr.arr.splice(i,0,...val.arr.slice(0,+size))
}

/**
 * @function
 * @param {any} val
 * @returns {void}
*/
function array_push(a, val) {a = new $ref(a)
a.val.arr.make_copy()
if (arguments[2] && arguments[2].valueOf()) {a.val.arr.arr.push(...val)} else {
a.val.arr.arr.push(val)
}
a.val.arr.len.val += 1
}

/**
 * @function
 * @param {array} arr
 * @param {anon_fn_voidptr__bool} callback
 * @returns {array}
*/
function v_filter(arr, callback) {/** @type {array} */
let filtered = empty_array();
for (let i = new int(new int(0)); +new bool(i.valueOf() < arr.arr.len.valueOf()); i.val ++) {
if ((callback(array_buffer_get(arr.arr,i))).valueOf()) {
array_push(filtered,array_buffer_get(arr.arr,i));
}
}

return filtered;
}

/**
 * @function
 * @param {array} arr
 * @param {anon_fn_voidptr__voidptr} callback
 * @returns {array}
*/
function v_map(arr, callback) {/** @type {array} */
let maped = empty_array();
for (let i = new int(new int(0)); +new bool(i.valueOf() < arr.arr.len.valueOf()); i.val ++) {
array_push(maped,callback(array_buffer_get(arr.arr,i)));
}

return maped;
}

/**
 * @constructor
 * @param {{ix?: int, end?: int, arr?: JS__Array}} init
*/
function array_iterator({ ix = new int(0), end = new int(0), arr = new Array() }) {
	this.ix = ix
	this.end = end
	this.arr = arr
};
array_iterator.prototype = {
	toString() {
		return `array_iterator { ix: ${this["ix"].toString()} , end: ${this["end"].toString()} , arr: ${this["arr"].toString()} }`
	},
	/** @type {int} */
	ix: new int(0),
	/** @type {int} */
	end: new int(0),
	/** @type {JS__Array} */
	arr: new Array(),
	$toJS() { return this; }
	};

array_iterator.prototype.next = function () {
if (this.ix.val < this.end.val) {
this.ix.val++;
return {done: false, value: this.arr.arr.get(new int(this.ix.val-1))}
} else {
return {done: true, value: undefined}
}
}
array_iterator.prototype[Symbol.iterator] = function () { return this; }
array.prototype[Symbol.iterator] = function () { return new array_iterator({ix: new int(0),end: new int(this.arr.len),arr: this}); }
array.prototype.entries = function () { let result = []; for (let key = this.arr.index_start.val;key < this.arr.len.val;key++) { result.push([new int(key), this.arr.get(new int(key))]); } return result[Symbol.iterator](); }
array.prototype.map = function(callback) { return v_map(this,callback); }
array.prototype.filter = function(callback) { return v_filter(this,callback); }
Object.defineProperty(array.prototype,'cap',{ get: function () { return this.len; } })
array.prototype.any = function (value) {
let val ;if (typeof value == 'function') { val = function (x) { return value(x); } } else { val = function (x) { return vEq(x,value); } }
for (let i = 0;i < this.arr.arr.length;i++)
if (val(this.arr.get(i)))
return true;

return false;
}
array.prototype.all = function (value) {
let val ;if (typeof value == 'function') { val = function (x) { return value(x); } } else { val = function (x) { return vEq(x,value); } }
for (let i = 0;i < this.arr.arr.length;i++)
if (!val(this.arr.get(i)))
return false;

return true;
}


function v_makeSlice(array) { Object.defineProperty(array,'len', {get: function() { return this.arr.len; }, set: function(l) { this.arr.len = l; }}) }
/**
 * @function
 * @param {int} i
 * @returns {void}
*/
function array_delete(a, i) {a = new $ref(a)
array_delete_many(a.val,i, new int(1));
}

/**
 * @function
 * @param {array} dst
 * @param {array} src
 * @param {int} count
 * @returns {void}
*/
function arr_copy(dst, src, count) {dst = new $ref(dst)
for (let i = new int(new int(0)); +new bool(i.valueOf() < count.valueOf()); i.val ++) {
array_buffer_set(dst.val.arr,i, array_buffer_get(src.arr,i));
}

}

/**
 * @function
 * @param {int} i
 * @param {int} size
 * @returns {void}
*/
function array_delete_many(a, i, size) {a = new $ref(a)
a.val.arr.make_copy()
a.val.arr.arr.splice(i.valueOf(),size.valueOf())
}

/**
 * @function
 * @param {any} val
 * @returns {void}
*/
function array_prepend(a, val) {a = new $ref(a)
array_insert(a.val,new int(0), val);
}

/* [unsafe] */
/**
 * @function
 * @param {any} val
 * @param {int} size
 * @returns {void}
*/
function array_prepend_many(a, val, size) {a = new $ref(a)
array_insert_many(a.val,new int(0), val, size);
}

/**
 * @function
 * @returns {array}
*/
function array_reverse(a) {/** @type {array} */
let res = empty_array();
res.arr.arr = Array.from(a.arr).reverse()
return res;
}

/**
 * @function
 * @returns {void}
*/
function array_reverse_in_place(a) {a = new $ref(a)
a.val.arr.arr.reverse()
}

array.prototype.$includes = function (elem) { return this.arr.arr.find(function(e) { return vEq(elem,e); }) !== undefined;}
/**
 * @function
 * @returns {void}
*/
function array_clear(a) {a = new $ref(a)
a.val.arr.make_copy()
a.val.arr.arr.clear()
}

/**
 * @function
 * @param {anon_fn_int_int__int} iter
 * @param {int} accum_start
 * @returns {int}
*/
function array_reduce(a, iter, accum_start) {/** @type {int} */
let accum_ = new int(accum_start);
for (let i = new int(0); i < a.len; i = new int(i + 1)) {
/** @type {int} */
accum_ = new int(iter(accum_, array_get(a,i)));
}

return accum_;
}

/**
 * @function
 * @returns {any}
*/
function array_pop(a) {a = new $ref(a)
/** @type {any} */
let res = new any(new int(0));
a.val.arr.make_copy()
res = a.val.arr.arr.pop()
a.val.arr.len.val -= 1
return res;
}

/**
 * @function
 * @returns {any}
*/
function array_first(a) {/** @type {any} */
let res = new any(new int(0));
res = a.arr.get(new int(0))
return res;
}

array.prototype.toString = function () {
let res = "["
for (let i = 0; i < this.arr.arr.length;i++) {
res += this.arr.get(i).toString();
if (i != this.arr.arr.length-1)
res += ', '
}
res += ']'
return res;

}
/**
 * @function
 * @param {any} key
 * @returns {bool}
*/
function array_contains(a, key) {}

/**
 * @function
 * @returns {void}
*/
function array_delete_last(a) {a = new $ref(a)
a.val.arr.arr.pop();
}

/* [unsafe] */
/**
 * @function
 * @returns {void}
*/
function array_free(a) {a = new $ref(a)
}

/**
 * @function
 * @returns {string}
*/
function array_bytestr(a) {/** @type {string} */
const res = new string(new string(""));
for (let i = 0;i < a.arr.len.valueOf();i++) res.str += String.fromCharCode(a.arr.get(new int(i)))
return res;
}

/**
 * @function
 * @returns {string}
*/
function Array_string_str(a) {/** @type {strings__Builder} */
let sb = strings__new_builder(new int( a.len.valueOf() * new int(3).valueOf()));
strings__Builder_write_string(sb,new string("["));
for (let i = new int(0); i < a.len; i = new int(i + 1)) {
/** @type {string} */
const val = new string(a.arr.get(new int(i.valueOf())));
strings__Builder_write_string(sb,new string("'"));
strings__Builder_write_string(sb,val);
strings__Builder_write_string(sb,new string("'"));
if ((new bool(i.valueOf() < new int( a.len.valueOf() - new int(1).valueOf()).valueOf())).valueOf()) {
strings__Builder_write_string(sb,new string(", "));
}
}

strings__Builder_write_string(sb,new string("]"));
/** @type {string} */
const res = new string(strings__Builder_str(new $ref(sb)));
return res;
}

/** @namespace builtin */
/* [noreturn] */
/**
 * @function
 * @param {any} s
 * @returns {void}
*/
function js_throw(s) {throw s
while (true) {
}

}

let globalPrint;
if (false)
{
globalPrint = globalThis.print
}
/**
 * @function
 * @param {string} s
 * @returns {void}
*/
function builtin__println(s) {if (false)
{
globalPrint(s.str)
}
else
{
console.log(s.str)
}
}

/**
 * @function
 * @param {string} s
 * @returns {void}
*/
function builtin__print(s) {if (true)
{
$process.stdout.write(s.str)
}
else
{
builtin__panic (new string("Cannot `print` in a browser, use `println` instead"));
}
}

/**
 * @function
 * @param {string} s
 * @returns {void}
*/
function builtin__eprintln(s) {if (false)
{
globalPrint(s.str)
}
else
{
console.error(s.str)
}
}

/**
 * @function
 * @param {string} s
 * @returns {void}
*/
function builtin__eprint(s) {if (true)
{
$process.stderr.write(s.str)
}
else
{
builtin__panic (new string("Cannot `eprint` in a browser, use `println` instead"));
}
}

/* [noreturn] */
/**
 * @function
 * @param {int} c
 * @returns {void}
*/
function builtin__exit(c) {process.exit(c);
js_throw(new string(`exit(${int_str(c)})`));
}

/**
 * @function
 * @param {any} data
 * @param {Option} option
 * @returns {void}
*/
function opt_ok(data, option) {option.state = 0
option.err = none__
option.data = data
}

/**
 * @function
 * @param {string} opt
 * @returns {string}
*/
function unwrap(opt) {/** @type {Option} */
let o = new Option({});
o = opt
if ((new bool(o.state.valueOf() != new int(0).valueOf())).valueOf()) {
js_throw(o.err);
}
/** @type {string} */
let res = new string(new string(""));
res = opt.data
return res;
}

/**
 * @function
 * @returns {string}
*/
function js_stacktrace() {/** @type {string} */
const stacktrace = new string(new string(""));
let err = new TypeError();
err.name = 'stacktrace: '
stacktrace.str = err.stack
return stacktrace;
}

/**
 * @function
 * @param {any} val
 * @returns {bool}
*/
function builtin__isnil(val) {/** @type {bool} */
const res = new bool(new bool(false));
val = val.valueOf()
res.val = val === null || val === undefined || val === false || val === 0 || val === BigInt(0)
return res;
}

/**
 * @function
 * @returns {string}
*/
function float_literal_str(f) {/** @type {string} */
const res = new string(new string(""));
res.str += f.valueOf()
return res;
}

/** @namespace builtin */
/**
 * @function
 * @returns {void}
*/
function any_toString(a) {}

/**
 * @function
 * @param {string} s
 * @returns {void}
*/
function builtin__panic(s) {builtin__eprintln (new string(`V panic: ${s}\n${js_stacktrace()}`));
builtin__exit(new int(1));
}

/**
 * @interface IError
 * @typedef IError
 */

function IError (arg) { return arg; }
/**
 * @constructor
 * @param {{msg?: string, code?: int}} init
*/
function Error({ msg = new string(""), code = new int(0) }) {
	this.msg = msg
	this.code = code
};
Error.prototype = {
	toString() {
		return `Error { msg: "${this["msg"].toString()}", code: ${this["code"].toString()} }`
	},
	/** @type {string} */
	msg: new string(""),
	/** @type {int} */
	code: new int(0),
	$toJS() { return this; }
	};

/**
 * @constructor
 * @param {{msg?: string, code?: int}} init
*/
function None__({ msg = new string(""), code = new int(0) }) {
	this.msg = msg
	this.code = code
};
None__.prototype = {
	toString() {
		return `None__ { msg: "${this["msg"].toString()}", code: ${this["code"].toString()} }`
	},
	/** @type {string} */
	msg: new string(""),
	/** @type {int} */
	code: new int(0),
	$toJS() { return this; }
	};

/**
 * @function
 * @returns {string}
*/
function None___str(_) {return new string("none");
}

/** @constant {IError} */
const none__ = new IError(new None__({
	msg: new string(""),
	code: new int(0)
}));

/**
 * @constructor
 * @param {{state?: byte, err?: IError}} init
*/
function Option({ state = new byte(0), err = none__ }) {
	this.state = state
	this.err = err
};
Option.prototype = {
	toString() {
		return `Option { state: ${this["state"].toString()} , err: ${this["err"].toString()} }`
	},
	/** @type {byte} */
	state: new byte(0),
	/** @type {IError} */
	err: undefined,
	$toJS() { return this; }
	};

/**
 * @function
 * @returns {string}
*/
function IError_str(err) {return ((err instanceof None__) ? (new string("none")) : (err instanceof Error) ? (err.val.msg) : (new string(`Error: ${err.msg}`)));
}

/**
 * @function
 * @returns {string}
*/
function Option_str(o) {if ((new bool(o.state.valueOf() == new int(0).valueOf())).valueOf()) {
return new string("Option{ ok }");
}
if ((new bool(o.state.valueOf() == new int(1).valueOf())).valueOf()) {
return new string("Option{ none }");
}
return new string(`Option{ error: "${IError_str(o.err)}" }`);
}

/**
 * @function
 * @param {string} x
 * @returns {void}
*/
function trace_error(x) {builtin__eprintln (new string(`> ${"trace_error"} | ${x}`));
}

/* [inline] */
/**
 * @function
 * @param {string} message
 * @returns {IError}
*/
function error(message) {return new $ref(new Error({
	msg: message
}));
}

/* [inline] */
/**
 * @function
 * @param {string} message
 * @param {int} code
 * @returns {IError}
*/
function error_with_code(message, code) {return new $ref(new Error({
	msg: message,
	code: code
}));
}

/** @namespace builtin */
/**
 * @function
 * @returns {bool}
*/
function byte_is_space(b) {/** @type {bool} */
let result = new bool(new bool(false));
result.val = /^\s*$/.test(String.fromCharCode(b))
return result;
}

/**
 * @function
 * @returns {string}
*/
function byte_str(c) {/** @type {string} */
const res = new string(new string(""));
res.str = c.val.toString()
return res;
}

/**
 * @function
 * @returns {string}
*/
function byte_ascii_str(c) {/** @type {string} */
const res = new string(new string(""));
res.str = String.fromCharCode(c.val)
return res;
}

/**
 * @function
 * @param {int} count
 * @returns {string}
*/
function byte_repeat(c, count) {/** @type {string} */
let res = new string(new string(""));
for (let _tmp4 = new int(0); _tmp4 < count; _tmp4 = new int(_tmp4 + 1)) {
/** @type {string} */
res.str = res + new string(byte_ascii_str(c,));
}

return res;
}

/**
 * @function
 * @returns {bool}
*/
function byte_is_digit(c) {return new bool( new bool(c.valueOf() >= new byte('0').valueOf()).valueOf() && new bool(c.valueOf() <= new byte('9').valueOf()).valueOf());
}

/* [inline] */
/**
 * @function
 * @returns {bool}
*/
function byte_is_hex_digit(c) {return new bool( new bool( byte_is_digit(c,).valueOf() || (new bool( new bool(c.valueOf() >= new byte('a').valueOf()).valueOf() && new bool(c.valueOf() <= new byte('f').valueOf()).valueOf())).valueOf()).valueOf() || (new bool( new bool(c.valueOf() >= new byte('A').valueOf()).valueOf() && new bool(c.valueOf() <= new byte('F').valueOf()).valueOf())).valueOf());
}

/* [inline] */
/**
 * @function
 * @returns {bool}
*/
function byte_is_oct_digit(c) {return new bool( new bool(c.valueOf() >= new byte('0').valueOf()).valueOf() && new bool(c.valueOf() <= new byte('7').valueOf()).valueOf());
}

/* [inline] */
/**
 * @function
 * @returns {bool}
*/
function byte_is_bin_digit(c) {return new bool( new bool(c.valueOf() == new byte('0').valueOf()).valueOf() || new bool(c.valueOf() == new byte('1').valueOf()).valueOf());
}

/* [inline] */
/**
 * @function
 * @returns {bool}
*/
function byte_is_letter(c) {return new bool( (new bool( new bool(c.valueOf() >= new byte('a').valueOf()).valueOf() && new bool(c.valueOf() <= new byte('z').valueOf()).valueOf())).valueOf() || (new bool( new bool(c.valueOf() >= new byte('A').valueOf()).valueOf() && new bool(c.valueOf() <= new byte('Z').valueOf()).valueOf())).valueOf());
}

/* [inline] */
/**
 * @function
 * @returns {bool}
*/
function byte_is_alnum(c) {return new bool( byte_is_letter(c,).valueOf() || byte_is_digit(c,).valueOf());
}

/**
 * @function
 * @returns {bool}
*/
function byte_is_capital(c) {return new bool( new bool(c.valueOf() >= new byte('A').valueOf()).valueOf() && new bool(c.valueOf() <= new byte('Z').valueOf()).valueOf());
}

/**
 * @function
 * @returns {string}
*/
function byte_str_escaped(b) {/** @type {string} */
let str = new string(new string(""));

if (vEq(b,new int(0))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(48);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(7))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(97);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(8))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(98);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(9))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(116);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(10))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(110);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(11))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(118);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(12))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(102);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(13))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(114);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if (vEq(b,new int(27))) {
	/** @type {string} */
	str = new string(new string((function() { let s = String(); 
	s += String.fromCharCode(96);
	s += String.fromCharCode(92);
	s += String.fromCharCode(101);
	s += String.fromCharCode(96);
	return s; })()
	));
}
else if ((b >= new int(32) && b <= new int(126))) {
	/** @type {string} */
	str = new string(byte_ascii_str(b,));
}
else {
	/** @type {string} */
	str = new string(new string( new string("0x").valueOf() + byte_hex(b,).valueOf()));
};
return str;
}

/** @namespace builtin */
/**
 * @function
 * @returns {string}
*/
function f32_str(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val + ''
return res;
}

/**
 * @function
 * @returns {string}
*/
function f64_str(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val + ''
return res;
}

/** @namespace builtin */
/**
 * @function
 * @returns {string}
*/
function i8_str(i) {/** @type {string} */
let res = new string(new string(""));
res.str = i.val.toString()
return res;
}

/**
 * @function
 * @returns {string}
*/
function i16_str(i) {/** @type {string} */
let res = new string(new string(""));
res.str = i.val.toString()
return res;
}

/**
 * @function
 * @returns {string}
*/
function u16_str(i) {/** @type {string} */
let res = new string(new string(""));
res.str = i.val.toString()
return res;
}

/**
 * @function
 * @returns {string}
*/
function int_str(i) {/** @type {string} */
let res = new string(new string(""));
res = new string( i+'' )
return res;
}

/**
 * @function
 * @returns {string}
*/
function i64_str(i) {/** @type {string} */
let res = new string(new string(""));
res = new string( i + '')
return res;
}

/**
 * @function
 * @returns {string}
*/
function u32_str(i) {/** @type {string} */
let res = new string(new string(""));
res = new string( i + '')
return res;
}

/**
 * @function
 * @returns {string}
*/
function u64_str(i) {/** @type {string} */
let res = new string(new string(""));
res = new string( i + '')
return res;
}

/**
 * @function
 * @returns {string}
*/
function bool_str(i) {/** @type {string} */
let res = new string(new string(""));
res = new string( i + '')
return res;
}

/**
 * @function
 * @returns {string}
*/
function any_str(i) {/** @type {string} */
let res = new string(new string(""));
res = new string( i.toString() )
return res;
}

/**
 * @function
 * @returns {string}
*/
function int_literal_str(i) {/** @type {string} */
const res = new string(new string(""));
res.str = i.val.toString()
return res;
}

/**
 * @function
 * @returns {string}
*/
function u64_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function i64_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function u32_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function u16_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function i8_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function i16_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function int_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function int_literal_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function byte_hex(x) {/** @type {string} */
const res = new string(new string(""));
res.str = x.val.toString(16)
return res;
}

/**
 * @function
 * @returns {string}
*/
function Array_byte_hex(b) {/** @type {string} */
let hex = new string(new string(""));
for (const i of b) {
/** @type {byte} */
let z = new byte(i);
/** @type {byte} */
z = new byte(z);
let n0 = i.val >> 4
hex.str += n0 < 10 ? String.fromCharCode(n0) : String.fromCharCode(n0 + 87)
let n1 = i.val & 0xF
hex.str += n1 < 10 ? String.fromCharCode(n1) : String.fromCharCode(n1 + 87)
}

return hex;
}

/** @namespace builtin */
/**
 * @function
 * @param {Array_JS__String} arr
 * @returns {int}
*/
function native_str_arr_len(arr) {/** @type {int} */
const len = new int(new int(0));
len = arr.length
return len;
}

/** @namespace builtin */
/** @namespace builtin */
/**
 * @function
 * @returns {JS__node_process}
*/
function js_node_process() {return process
return new node_process({});
}

/** @namespace builtin */
/* [unsafe] */
/**
 * @function
 * @param {any} key
 * @returns {void}
*/
function map_delete(m, key) {m = new $ref(m)
m.map.delete(key)
}

/**
 * @function
 * @returns {void}
*/
function map_free(m) {m = new $ref(m)
}

map.prototype[Symbol.iterator] = function () { return this.map[Symbol.iterator](); }
map.prototype.toString = function () {
function fmtKey(key) { return typeof key == 'string' ? '\'' + key + '\'' : key}
let res = '{'
for (const entry of this) {
res += fmtKey(entry[0]) + ': ' + entry[0];
}
res += '}'
return res;
}
map.prototype.getOrSet = function (key, init) { if (this.map.has(key)) { return this.map.get(key); } else { this.map.set(key,init); return init; } }
/** @namespace builtin */
/**
 * @function
 * @returns {string}
*/
function Array_rune_string(ra) {/** @type {strings__Builder} */
let sb = strings__new_builder(ra.len);
strings__Builder_write_runes(sb,ra);
/** @type {string} */
const res = new string(strings__Builder_str(new $ref(sb)));
return res;
}

/**
 * @function
 * @param {int} count
 * @returns {string}
*/
function rune_repeat(c, count) {if ((new bool(count.valueOf() < new int(0).valueOf())).valueOf()) {
builtin__panic (new string(`rune.repeat: count is negative: ${int_str(count)}`));
} else if ((new bool(count.valueOf() == new int(0).valueOf())).valueOf()) {
return new string("");
} else if ((new bool(count.valueOf() == new int(1).valueOf())).valueOf()) {
return rune_str(c);
}
/** @type {string} */
const res = new string(new string(""));
res.str = String.fromCharCode(c.val)
return string_repeat(res,count);
}

/**
 * @function
 * @returns {string}
*/
function rune_str(c) {/** @type {string} */
const res = new string(new string(""));
res.str = String.fromCharCode(c.val)
return res;
}

/** @namespace builtin */
/**
 * @function
 * @returns {Array_rune}
*/
function string_runes(s) {/** @type {Array_rune} */
let runes = new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
for (let i = new int(new int(0)); +new bool(i.valueOf() < s.len.valueOf()); i.val ++) {
let r = new rune(new byte('0')); r = new rune(s.str[i.val].charCodeAt())
array_push(runes,r,false);
}

return runes;
}

/**
 * @function
 * @param {int} a
 * @param {int} b
 * @returns {string}
*/
function string_slice(s, a, b) {return new string(s.str.slice(a, b).toString());
}

/**
 * @function
 * @param {int} start
 * @param {int} end
 * @returns {string}
*/
function string_substr(s, start, end) {return string_slice(s,start, end);
}

/**
 * @function
 * @param {string} dot
 * @returns {string}
*/
function string_after(s, dot) {return new string(s.str.slice(new int( s.str.lastIndexOf(dot.str).valueOf() + new int(1).valueOf()), new int(s.str.length)).toString());
}

/**
 * @function
 * @param {byte} dot
 * @returns {string}
*/
function string_after_char(s, dot) {return s;
}

/**
 * @function
 * @param {string} dot
 * @returns {string}
*/
function string_all_after(s, dot) {/** @type {int} */
const pos = new int(((new bool(dot.len.valueOf() == new int(0).valueOf())).valueOf() ? new int(-1) : s.str.indexOf(dot.str)));
if ((new bool(pos.valueOf() == new int(-1).valueOf())).valueOf()) {
return string_clone(s,);
}
return string_slice(s,new int( pos.valueOf() + dot.len.valueOf()), s.len);
}

/**
 * @function
 * @param {string} dot
 * @returns {string}
*/
function string_all_after_last(s, dot) {/** @type {int} */
const pos = new int(((new bool(dot.len.valueOf() == new int(0).valueOf())).valueOf() ? new int(-1) : s.str.lastIndexOf(dot.str)));
if ((new bool(pos.valueOf() == new int(-1).valueOf())).valueOf()) {
return string_clone(s,);
}
return string_slice(s,new int( pos.valueOf() + dot.len.valueOf()), s.len);
}

/**
 * @function
 * @param {string} dot
 * @returns {string}
*/
function string_all_before(s, dot) {/** @type {int} */
const pos = new int(((new bool(dot.len.valueOf() == new int(0).valueOf())).valueOf() ? new int(-1) : s.str.indexOf(dot.str)));
if ((new bool(pos.valueOf() == new int(-1).valueOf())).valueOf()) {
return string_clone(s,);
}
return string_slice(s,new int(0), pos);
}

/**
 * @function
 * @param {string} dot
 * @returns {string}
*/
function string_all_before_last(s, dot) {/** @type {int} */
const pos = new int(((new bool(dot.len.valueOf() == new int(0).valueOf())).valueOf() ? new int(-1) : s.str.lastIndexOf(dot.str)));
if ((new bool(pos.valueOf() == new int(-1).valueOf())).valueOf()) {
return string_clone(s,);
}
return string_slice(s,new int(0), pos);
}

/**
 * @function
 * @returns {bool}
*/
function string_bool(s) {return new bool(s.valueOf() == new string("true").valueOf());
}

/**
 * @function
 * @param {string} dot
 * @returns {Array_string}
*/
function string_split(s, dot) {/** @type {Array_string} */
let arr = s.str.split(dot.str).map(it => new string(it.toString()));
arr = new array(new array_buffer({arr,index_start: new int(0),len: new int(arr.length)}))
return arr;
}

/**
 * @function
 * @returns {Array_byte}
*/
function string_bytes(s) {/** @type {string} */
const sep = new string(new string(""));
/** @type {Array_byte} */
let arr = s.str.split(sep.str).map(it => it.charCodeAt(new int(0)));
arr = new array(new array_buffer({arr,index_start: new int(0),len: new int(arr.length)}))
return arr;
}

/**
 * @function
 * @returns {string}
*/
function string_capitalize(s) {/** @type {string} */
const part = new string(new string(s.str.slice(new int(1), new int(s.str.length)).toString()));
return new string(s.str.charAt(new int(0)).toUpperCase().concat(part.str).toString());
}

/**
 * @function
 * @returns {string}
*/
function string_clone(s) {return new string(s.str.toString());
}

/**
 * @function
 * @param {string} substr
 * @returns {bool}
*/
function string_contains(s, substr) {return s.str.includes(substr.str);
}

/**
 * @function
 * @param {string} chars
 * @returns {bool}
*/
function string_contains_any(s, chars) {/** @type {string} */
const sep = new string(new string(""));
for (const x of chars.str.split(sep.str)) {
if ((s.str.includes(x)).valueOf()) {
return new bool(true);
}
}

return new bool(false);
}

/**
 * @function
 * @param {Array_string} chars
 * @returns {bool}
*/
function string_contains_any_substr(s, chars) {if ((new bool(chars.len.valueOf() == new int(0).valueOf())).valueOf()) {
return new bool(true);
}
for (const x of chars) {
if ((s.str.includes(x.str)).valueOf()) {
return new bool(true);
}
}

return new bool(false);
}

/**
 * @function
 * @param {string} substr
 * @returns {int}
*/
function string_count(s, substr) {/** @type {Array_JS__String} */
const arr = s.str.split(substr.str);
return native_str_arr_len(arr);
}

/**
 * @function
 * @param {string} p
 * @returns {bool}
*/
function string_ends_with(s, p) {/** @type {bool} */
let res = new bool(new bool(false));
res.val = s.str.endsWith(p.str)
return res;
}

/**
 * @function
 * @param {string} p
 * @returns {bool}
*/
function string_starts_with(s, p) {return s.str.startsWith(p.str);
}

/**
 * @function
 * @returns {Array_string}
*/
function string_fields(s) {/** @type {Array_string} */
let res = new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
/** @type {int} */
let word_start = new int(new int(0));
/** @type {int} */
let word_len = new int(new int(0));
/** @type {bool} */
let is_in_word = new bool(new bool(false));
/** @type {bool} */
let is_space = new bool(new bool(false));
for (const [i, c] of Array.from(s.str.split('').entries(), ([i, c]) => [i, new byte(c)])) {
/** @type {bool} */
is_space = new bool((Array_int_contains(new array(new array_buffer({arr: [new int(new int(32)), new int(new int(9)), new int(new int(10))], len: new int(3), cap: new int(3)})),c)));
if ((!(is_space.valueOf())).valueOf()) {
word_len.val ++;
}
if ((new bool( !(is_in_word.valueOf()).valueOf() && !(is_space.valueOf()).valueOf())).valueOf()) {
/** @type {int} */
word_start = new int(i);
/** @type {bool} */
is_in_word = new bool(new bool(true));
continue;
}
if ((new bool( is_space.valueOf() && is_in_word.valueOf())).valueOf()) {
array_push(res,string_slice(s,word_start, new int( word_start.valueOf() + word_len.valueOf())),false);
/** @type {bool} */
is_in_word = new bool(new bool(false));
/** @type {int} */
word_len = new int(new int(0));
/** @type {int} */
word_start = new int(new int(0));
continue;
}
}

if ((new bool( is_in_word.valueOf() && new bool(word_len.valueOf() > new int(0).valueOf()).valueOf())).valueOf()) {
array_push(res,string_slice(s,word_start, s.len),false);
}
return res;
}

/**
 * @function
 * @param {string} start
 * @param {string} end
 * @returns {string}
*/
function string_find_between(s, start, end) {return new string(s.str.slice(new int( s.str.indexOf(start.str).valueOf() + new int(1).valueOf()), s.str.indexOf(end.str)).toString());
}

/**
 * @function
 * @returns {void}
*/
function string_free(s) {s = new $ref(s)
}

/**
 * @function
 * @returns {int}
*/
function string_hash(s) {/** @type {u32} */
let h = new u32(new int(0));
if ((new bool( new bool(h.valueOf() == new int(0).valueOf()).valueOf() && new bool(s.len.valueOf() > new int(0).valueOf()).valueOf())).valueOf()) {
for (const c of s.str.split('').map(c => new byte(c))) {
/** @type {u32} */
h = new u32(new u32( new u32( h.valueOf() * new int(31).valueOf()).valueOf() + new u32(c).valueOf()));
}

}
return new int(h);
}

/**
 * @function
 * @returns {int}
*/
function string_int(s) {return new int(parseInt(s));
}

/**
 * @function
 * @returns {i64}
*/
function string_i64(s) {return new i64(parseInt(s));
}

/**
 * @function
 * @returns {i8}
*/
function string_i8(s) {return new i8(parseInt(s));
}

/**
 * @function
 * @returns {i16}
*/
function string_i16(s) {return new i16(parseInt(s));
}

/**
 * @function
 * @returns {f32}
*/
function string_f32(s) {return new f32(parseFloat(s));
}

/**
 * @function
 * @returns {f64}
*/
function string_f64(s) {return new f64(parseFloat(s));
}

/**
 * @function
 * @returns {u16}
*/
function string_u16(s) {return new u16(parseInt(s));
}

/**
 * @function
 * @returns {u32}
*/
function string_u32(s) {return new u32(parseInt(s));
}

/**
 * @function
 * @returns {u64}
*/
function string_u64(s) {return new u64(parseInt(s));
}

/**
 * @function
 * @returns {u64}
*/
function string_byte(s) {/** @type {byte} */
const res = new byte(new int(0));
res.val = byte(JS.parseInt(s))
return res;
}

/**
 * @function
 * @param {string} cutset
 * @returns {string}
*/
function string_trim_right(s, cutset) {if ((new bool( new bool(s.len.valueOf() < new int(1).valueOf()).valueOf() || new bool(cutset.len.valueOf() < new int(1).valueOf()).valueOf())).valueOf()) {
return string_clone(s,);
}
/** @type {int} */
let pos = new int(new int( s.len.valueOf() - new int(1).valueOf()));
while (+new bool(pos.valueOf() >= new int(0).valueOf())) {
/** @type {bool} */
let found = new bool(new bool(false));
for (const cs of cutset.str.split('').map(c => new byte(c))) {
if ((new bool(new byte(s.str.charCodeAt(pos)).valueOf() == cs.valueOf())).valueOf()) {
/** @type {bool} */
found = new bool(new bool(true));
}
}

if ((!(found.valueOf())).valueOf()) {
break;
}
pos.val --;
}

if ((new bool(pos.valueOf() < new int(0).valueOf())).valueOf()) {
return new string("");
}
return string_slice(s,new int(0), new int( pos.valueOf() + new int(1).valueOf()));
}

/* [direct_array_access] */
/**
 * @function
 * @param {string} cutset
 * @returns {string}
*/
function string_trim_left(s, cutset) {if ((new bool( new bool(s.len.valueOf() < new int(1).valueOf()).valueOf() || new bool(cutset.len.valueOf() < new int(1).valueOf()).valueOf())).valueOf()) {
return string_clone(s,);
}
/** @type {int} */
let pos = new int(new int(0));
while (+new bool(pos.valueOf() < s.len.valueOf())) {
/** @type {bool} */
let found = new bool(new bool(false));
for (const cs of cutset.str.split('').map(c => new byte(c))) {
if ((new bool(new byte(s.str.charCodeAt(pos)).valueOf() == cs.valueOf())).valueOf()) {
/** @type {bool} */
found = new bool(new bool(true));
break;
}
}

if ((!(found.valueOf())).valueOf()) {
break;
}
pos.val ++;
}

return string_slice(s,pos, s.len);
}

/**
 * @function
 * @param {string} str
 * @returns {string}
*/
function string_trim_prefix(s, str) {if ((string_starts_with(s,str)).valueOf()) {
return string_slice(s,str.len, s.len);
}
return string_clone(s,);
}

/**
 * @function
 * @param {string} str
 * @returns {string}
*/
function string_trim_suffix(s, str) {if ((string_ends_with(s,str)).valueOf()) {
return string_slice(s,new int(0), new int( s.len.valueOf() - str.len.valueOf()));
}
return string_clone(s,);
}

/**
 * @function
 * @param {string} a
 * @param {string} b
 * @returns {int}
*/
function compare_strings(a, b) {a = new $ref(a)
b = new $ref(b)
if ((new bool(a.val.valueOf() < b.val.valueOf())).valueOf()) {
return new int(-1);
}
if ((new bool(a.val.valueOf() > b.val.valueOf())).valueOf()) {
return new int(1);
}
return new int(0);
}

/**
 * @function
 * @param {string} a
 * @param {string} b
 * @returns {int}
*/
function compare_strings_reverse(a, b) {a = new $ref(a)
b = new $ref(b)
if ((new bool(a.val.valueOf() < b.val.valueOf())).valueOf()) {
return new int(1);
}
if ((new bool(a.val.valueOf() > b.val.valueOf())).valueOf()) {
return new int(-1);
}
return new int(0);
}

/**
 * @function
 * @param {string} a
 * @param {string} b
 * @returns {int}
*/
function compare_strings_by_len(a, b) {a = new $ref(a)
b = new $ref(b)
if ((new bool(a.val.len.valueOf() < b.val.len.valueOf())).valueOf()) {
return new int(-1);
}
if ((new bool(a.val.len.valueOf() > b.val.len.valueOf())).valueOf()) {
return new int(1);
}
return new int(0);
}

/**
 * @function
 * @param {string} a
 * @param {string} b
 * @returns {int}
*/
function compare_lower_strings(a, b) {a = new $ref(a)
b = new $ref(b)
/** @type {string} */
const aa = new string(string_to_lower(a.val,));
/** @type {string} */
const bb = new string(string_to_lower(b.val,));
return compare_strings(new $ref(aa), new $ref(bb));
}

/**
 * @function
 * @param {int} idx
 * @returns {byte}
*/
function string_at(s, idx) {/** @type {byte} */
let result = new byte(new int(0));
result = new byte(s.str.charCodeAt(result))
return result;
}

/**
 * @function
 * @returns {string}
*/
function string_to_lower(s) {/** @type {string} */
let result = new string(new string(""));
let str = s.str.toLowerCase()
result = new string(str)
return result;
}

/**
 * @function
 * @param {string} old_sub
 * @param {string} new_sub
 * @returns {string}
*/
function string_replace(s, old_sub, new_sub) {/** @type {string} */
let result = new string(new string(""));
result = new string( s.str.replaceAll(old_sub.str, new_sub.str) )
return result;
}

/**
 * @function
 * @returns {string}
*/
function string_to_upper(s) {/** @type {string} */
let result = new string(new string(""));
let str = s.str.toUpperCase()
result = new string(str)
return result;
}

/**
 * @function
 * @returns {void}
*/
function Array_string_sort(s) {s = new $ref(s)
array_sort_with_compare(s.val,compare_strings);
}

/**
 * @function
 * @returns {void}
*/
function Array_string_sort_ignore_case(s) {s = new $ref(s)
array_sort_with_compare(s.val,compare_lower_strings);
}

/**
 * @function
 * @returns {void}
*/
function Array_string_sort_by_len(s) {s = new $ref(s)
array_sort_with_compare(s.val,compare_strings_by_len);
}

/**
 * @function
 * @returns {string}
*/
function string_str(s) {return string_clone(s,);
}

/**
 * @function
 * @param {int} count
 * @returns {string}
*/
function string_repeat(s, count) {/** @type {string} */
let result = new string(new string(""));
result = new string(s.str.repeat(count))
return result;
}

function string_iterator(string) { this.stringIteratorFieldIndex = 0; this.stringIteratorIteratedString = string.str; }
string_iterator.prototype.next = function next() {
var done = true;
var value = undefined;
var position = this.stringIteratorFieldIndex;
if (position !== -1) {
var string = this.stringIteratorIteratedString;
var length = string.length >>> 0;
if (position >= length) {
this.stringIteratorFieldIndex = -1;
} else {
done = false;
var first = string.charCodeAt(position);
if (first < 0xD800 || first > 0xDBFF || position + 1 === length)
value = new byte(string[position]);
else {
value = new byte(string[position]+string[position+1])
}
this.stringIteratorFieldIndex = position + value.length;
}
}
return {
value, done
}
}
string.prototype[Symbol.iterator] = function () { return new string_iterator(this) }
/**
 * @function
 * @returns {string}
*/
function string_strip_margin(s) {return string_strip_margin_custom(s,new byte('|'));
}

/* [direct_array_access] */
/**
 * @function
 * @param {byte} del
 * @returns {string}
*/
function string_strip_margin_custom(s, del) {/** @type {byte} */
let sep = new byte(del);
if ((byte_is_space(sep,)).valueOf()) {
builtin__eprintln (new string("Warning: `strip_margin` cannot use white-space as a delimiter"));
builtin__eprintln (new string("    Defaulting to `|`"));
/** @type {byte} */
sep = new byte(new byte('|'));
}
/** @type {Array_byte} */
let ret = new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
ret = new array()
/** @type {int} */
let count = new int(new int(0));
for (let i = new int(new int(0)); +new bool(i.valueOf() < s.len.valueOf()); i.val ++) {
if (((Array_int_contains(new array(new array_buffer({arr: [new int(new int(10)), new int(new int(13))], len: new int(2), cap: new int(2)})),new byte(s.str.charCodeAt(i))))).valueOf()) {
{
	ret.arr.set(new int(count.valueOf()),new byte(new byte(s.str.charCodeAt(i)))); }

count.val ++;
if ((new bool( new bool( new bool(new byte(s.str.charCodeAt(i)).valueOf() == new int(13).valueOf()).valueOf() && new bool(i.valueOf() < new int( s.len.valueOf() - new int(1).valueOf()).valueOf()).valueOf()).valueOf() && new bool(new byte(s.str.charCodeAt(new int( i.valueOf() + new int(1).valueOf()))).valueOf() == new int(10).valueOf()).valueOf())).valueOf()) {
{
	ret.arr.set(new int(count.valueOf()),new byte(new byte(s.str.charCodeAt(new int( i.valueOf() + new int(1).valueOf()))))); }

count.val ++;
i.val ++;
}
while (+new bool(new byte(s.str.charCodeAt(i)).valueOf() != sep.valueOf())) {
i.val ++;
if ((new bool(i.valueOf() >= s.len.valueOf())).valueOf()) {
break;
}
}

} else {
{
	ret.arr.set(new int(count.valueOf()),new byte(new byte(s.str.charCodeAt(i)))); }

count.val ++;
}
}

/** @type {string} */
let result = new string(new string(""));
for (let x of ret.arr) result.str += String.fromCharCode(x.val)
return result;
}

/* [direct_array_access] */
/**
 * @function
 * @param {string} delim
 * @param {int} nth
 * @returns {Array_string}
*/
function string_split_nth(s, delim, nth) {/** @type {Array_string} */
let res = new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
/** @type {int} */
let i = new int(new int(0));

if (vEq(delim.len,new int(0))) {
	/** @type {int} */
	i = new int(new int(1));
	for (const ch of s.str.split('').map(c => new byte(c))) {
	if ((new bool( new bool(nth.valueOf() > new int(0).valueOf()).valueOf() && new bool(i.valueOf() >= nth.valueOf()).valueOf())).valueOf()) {
	array_push(res,string_slice(s,i, s.len),false);
	break;
	}
	array_push(res,byte_str(ch),false);
	i.val ++;
	}
	
	return res;
}
else if (vEq(delim.len,new int(1))) {
	/** @type {int} */
	let start = new int(new int(0));
	/** @type {byte} */
	const delim_byte = new byte(new byte(delim.str.charCodeAt(new int(0))));
	while (+new bool(i.valueOf() < s.len.valueOf())) {
	if ((new bool(new byte(s.str.charCodeAt(i)).valueOf() == delim_byte.valueOf())).valueOf()) {
	/** @type {bool} */
	const was_last = new bool(new bool( new bool(nth.valueOf() > new int(0).valueOf()).valueOf() && new bool(res.len.valueOf() == new int( nth.valueOf() - new int(1).valueOf()).valueOf()).valueOf()));
	if ((was_last).valueOf()) {
	break;
	}
	/** @type {string} */
	const val = new string(string_slice(s,start, i));
	array_push(res,val,false);
	/** @type {int} */
	start = new int(new int( i.valueOf() + delim.len.valueOf()));
	/** @type {int} */
	i = new int(start);
	} else {
	i.val ++;
	}
	}
	
	if ((new bool( new bool(nth.valueOf() < new int(1).valueOf()).valueOf() || new bool(res.len.valueOf() < nth.valueOf()).valueOf())).valueOf()) {
	array_push(res,string_slice(s,start, s.len),false);
	}
	return res;
}
else {
	/** @type {int} */
	let start = new int(new int(0));
	while (+new bool(i.valueOf() <= s.len.valueOf())) {
	/** @type {bool} */
	const is_delim = new bool(new bool( new bool(new int( i.valueOf() + delim.len.valueOf()).valueOf() <= s.len.valueOf()).valueOf() && new bool(string_slice(s,i, new int( i.valueOf() + delim.len.valueOf())).valueOf() == delim.valueOf()).valueOf()));
	if ((is_delim).valueOf()) {
	/** @type {bool} */
	const was_last = new bool(new bool( new bool(nth.valueOf() > new int(0).valueOf()).valueOf() && new bool(res.len.valueOf() == new int( nth.valueOf() - new int(1).valueOf()).valueOf()).valueOf()));
	if ((was_last).valueOf()) {
	break;
	}
	/** @type {string} */
	const val = new string(string_slice(s,start, i));
	array_push(res,val,false);
	/** @type {int} */
	start = new int(new int( i.valueOf() + delim.len.valueOf()));
	/** @type {int} */
	i = new int(start);
	} else {
	i.val ++;
	}
	}
	
	if ((new bool( new bool(nth.valueOf() < new int(1).valueOf()).valueOf() || new bool(res.len.valueOf() < nth.valueOf()).valueOf())).valueOf()) {
	array_push(res,string_slice(s,start, s.len),false);
	}
	return res;
};
}

/**
 * @constructor
 * @param {{idx?: int, val_idx?: int}} init
*/
function RepIndex({ idx = new int(0), val_idx = new int(0) }) {
	this.idx = idx
	this.val_idx = val_idx
};
RepIndex.prototype = {
	toString() {
		return `RepIndex { idx: ${this["idx"].toString()} , val_idx: ${this["val_idx"].toString()} }`
	},
	/** @type {int} */
	idx: new int(0),
	/** @type {int} */
	val_idx: new int(0),
	$toJS() { return this; }
	};

/* [direct_array_access] */
/**
 * @function
 * @param {Array_string} vals
 * @returns {string}
*/
function string_replace_each(s, vals) {if ((new bool( new bool(s.len.valueOf() == new int(0).valueOf()).valueOf() || new bool(vals.len.valueOf() == new int(0).valueOf()).valueOf())).valueOf()) {
return string_clone(s,);
}
if ((new bool(new int( vals.len.valueOf() % new int(2).valueOf()).valueOf() != new int(0).valueOf())).valueOf()) {
builtin__eprintln (new string("string.replace_each(): odd number of strings"));
return string_clone(s,);
}
/** @type {Array_RepIndex} */
let idxs = new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
/** @type {int} */
let idx = new int(new int(0));
/** @type {int} */
let new_len = new int(s.len);
/** @type {string} */
const s_ = new string(string_clone(s,));
function setCharAt(str,index,chr) {
if(index > str.length-1) return str;
return str.substring(0,index) + chr + str.substring(index+1);
}
for (let rep_i = new int(new int(0)); +new bool(rep_i.valueOf() < vals.len.valueOf()); rep_i = new int(new int( rep_i.valueOf() + new int(2).valueOf()))) {
let rep = new string(vals.arr.get(new int(rep_i.valueOf()))); let with_ = new string(vals.arr.get(new int(new int( rep_i.valueOf() + new int(1).valueOf()).valueOf()))); with_ = new string(with_); while (true) {
idx = new int(string_index_after(s_,rep, idx)); if ((new bool(idx.valueOf() == new int(-1).valueOf())).valueOf()) {
break;
}
for (let i = new int(0); i < rep.len; i = new int(i + 1)) {
/** @type {int} */
let j_ = new int(i);
/** @type {int} */
j_ = new int(j_);
s_.str = setCharAt(s_.str,idx + i, String.fromCharCode(127))
}

/** @type {RepIndex} */
const rep_idx = new RepIndex({
	idx: new int(0),
	val_idx: new int(0)
});
rep_idx.idx = idx.val
rep_idx.val_idx = new int(rep_i.val)
array_push(idxs,rep_idx,false);
/** @type {int} */
idx.val = idx + new int(rep.len);
/** @type {int} */
new_len.val = new_len + new int(new int( with_.len.valueOf() - rep.len.valueOf()));
}

}

if ((new bool(idxs.len.valueOf() == new int(0).valueOf())).valueOf()) {
return string_clone(s,);
}
v_sort(idxs,compare_RepIndex_by_idx);
/** @type {string} */
let b = new string(new string(""));
for (let i = 0; i < new_len.val;i++) b.str += String.fromCharCode(127)
/** @type {int} */
new_len = new int(new_len);
/** @type {int} */
let idx_pos = new int(new int(0));
/** @type {RepIndex} */
let cur_idx = idxs.arr.get(new int(idx_pos.valueOf()));
/** @type {int} */
let b_i = new int(new int(0));
for (let i = new int(new int(0)); +new bool(i.valueOf() < s.len.valueOf()); i.val ++) {
if ((new bool(i.valueOf() == cur_idx.idx.valueOf())).valueOf()) {
let rep = new string(vals.arr.get(new int(cur_idx.val_idx.valueOf()))); let with_ = new string(vals.arr.get(new int(new int( cur_idx.val_idx.valueOf() + new int(1).valueOf()).valueOf()))); for (let j = new int(0); j < with_.len; j = new int(j + 1)) {
/** @type {int} */
let j_ = new int(j);
/** @type {int} */
j_ = new int(j_);
b.str = setCharAt(b.str,b_i, with_.str[j])
b_i.val ++;
}

/** @type {int} */
i.val = i + new int(new int( rep.len.valueOf() - new int(1).valueOf()));
idx_pos.val ++;
if ((new bool(idx_pos.valueOf() < idxs.len.valueOf())).valueOf()) {
/** @type {RepIndex} */
cur_idx = idxs.arr.get(new int(idx_pos.valueOf()));
}
} else {
b.str = setCharAt(b.str,b_i,s.str[i]) //b.str[b_i] = s.str[i]
b_i.val ++;
}
}

return b;
}

/**
 * @function
 * @param {string} p
 * @returns {int}
*/
function string_last_index_(s, p) {if ((new bool( new bool(p.len.valueOf() > s.len.valueOf()).valueOf() || new bool(p.len.valueOf() == new int(0).valueOf()).valueOf())).valueOf()) {
return new int(-1);
}
/** @type {int} */
let i = new int(new int( s.len.valueOf() - p.len.valueOf()));
while (+new bool(i.valueOf() >= new int(0).valueOf())) {
/** @type {int} */
let j = new int(new int(0));
while (+new bool( new bool(j.valueOf() < p.len.valueOf()).valueOf() && new bool(new byte(s.str.charCodeAt(new int( i.valueOf() + j.valueOf()))).valueOf() == new byte(p.str.charCodeAt(j)).valueOf()).valueOf())) {
j.val ++;
}

if ((new bool(j.valueOf() == p.len.valueOf())).valueOf()) {
return i;
}
i.val --;
}

return new int(-1);
}

/**
 * @function
 * @param {string} p
 * @returns {int}
*/
function string_last_index(s, p) {/** @type {int} */
const idx = new int(string_last_index_(s,p));
if ((new bool(idx.valueOf() == new int(-1).valueOf())).valueOf()) {
return new Option({ state:  new byte(2),err: none__});
}
const _tmp5 = new Option({});
_tmp5.data = idx
return _tmp5;}

/**
 * @function
 * @returns {string}
*/
function string_trim_space(s) {/** @type {string} */
const res = new string(new string(""));
res.str = s.str.trim()
return res;
}

/**
 * @function
 * @param {string} p
 * @param {int} start
 * @returns {int}
*/
function string_index_after(s, p, start) {if ((new bool(p.len.valueOf() > s.len.valueOf())).valueOf()) {
return new int(-1);
}
/** @type {int} */
let strt = new int(start);
if ((new bool(start.valueOf() < new int(0).valueOf())).valueOf()) {
/** @type {int} */
strt = new int(new int(0));
}
if ((new bool(start.valueOf() >= s.len.valueOf())).valueOf()) {
return new int(-1);
}
/** @type {int} */
let i = new int(strt);
while (+new bool(i.valueOf() < s.len.valueOf())) {
/** @type {int} */
let j = new int(new int(0));
/** @type {int} */
let ii = new int(i);
while (+new bool( new bool(j.valueOf() < p.len.valueOf()).valueOf() && new bool(new byte(s.str.charCodeAt(ii)).valueOf() == new byte(p.str.charCodeAt(j)).valueOf()).valueOf())) {
j.val ++;
ii.val ++;
}

if ((new bool(j.valueOf() == p.len.valueOf())).valueOf()) {
return i;
}
i.val ++;
}

return new int(-1);
}

/**
 * @function
 * @returns {Array_string}
*/
function string_split_into_lines(s) {/** @type {Array_string} */
let res = new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
if ((new bool(s.len.valueOf() == new int(0).valueOf())).valueOf()) {
return res;
}
res.arr.arr = s.str.split("\n")
if (res.arr.arr[res.arr.arr.length-1] == "") res.arr.arr.pop();
res.arr.len = new int(res.arr.arr.length);
res.arr.cap = new int(res.arr.arr.length);
return res;
}

/**
 * @function
 * @param {string} rep
 * @param {string} with_
 * @returns {string}
*/
function string_replace_once(s, rep, with_) {/** @type {string} */
const s2 = new string(new string(""));
s2.val = s.str.replace(rep.str,with_.str)
return s2;
}

/**
 * @function
 * @returns {string}
*/
function string_title(s) {/** @type {Array_string} */
const words = string_split(s,new string(" "));
/** @type {Array_string} */
let tit = new array(new array_buffer({arr: [], len: new int(0), cap: new int(0)}));
for (const word of words) {
array_push(tit,string_capitalize(word,),false);
}

/** @type {string} */
const title = new string(Array_string_join(tit,new string(" ")));
return title;
}

/**
 * @function
 * @param {string} chars
 * @returns {int}
*/
function string_index_any(s, chars) {for (const [i, ss] of Array.from(s.str.split('').entries(), ([i, ss]) => [i, new byte(ss)])) {
for (const c of chars.str.split('').map(c => new byte(c))) {
if ((new bool(c.valueOf() == ss.valueOf())).valueOf()) {
return i;
}
}

}

return new int(-1);
}

/**
 * @function
 * @param {int} max
 * @returns {string}
*/
function string_limit(s, max) {/** @type {Array_rune} */
const u = string_runes(s,);
if ((new bool(u.len.valueOf() <= max.valueOf())).valueOf()) {
return string_clone(s,);
}
return Array_rune_string(array_slice(u,new int(0), max),);
}

/**
 * @function
 * @returns {bool}
*/
function string_is_title(s) {/** @type {Array_string} */
const words = string_split(s,new string(" "));
for (const word of words) {
if ((!(string_is_capital(word,).valueOf())).valueOf()) {
return new bool(false);
}
}

return new bool(true);
}

/* [direct_array_access] */
/**
 * @function
 * @returns {bool}
*/
function string_is_capital(s) {if ((new bool( new bool(s.len.valueOf() == new int(0).valueOf()).valueOf() || !((new bool( new bool(new byte(s.str.charCodeAt(new int(0))).valueOf() >= new byte('A').valueOf()).valueOf() && new bool(new byte(s.str.charCodeAt(new int(0))).valueOf() <= new byte('Z').valueOf()).valueOf())).valueOf()).valueOf())).valueOf()) {
return new bool(false);
}
for (let i = new int(1); i < s.len; i = new int(i + 1)) {
if ((new bool( new bool(new byte(s.str.charCodeAt(i)).valueOf() >= new byte('A').valueOf()).valueOf() && new bool(new byte(s.str.charCodeAt(i)).valueOf() <= new byte('Z').valueOf()).valueOf())).valueOf()) {
return new bool(false);
}
}

return new bool(true);
}

/**
 * @function
 * @returns {bool}
*/
function string_is_upper(s) {/** @type {bool} */
const res = new bool(new bool(false));
res.val = s.str == s.str.toUpperCase() && s.str != s.str.toLowerCase()
return res;
}

/**
 * @function
 * @returns {bool}
*/
function string_is_lower(s) {/** @type {bool} */
const res = new bool(new bool(false));
res.val = s.str == s.str.toLowerCase() && s.str != s.str.toUpperCase()
return res;
}

/**
 * @function
 * @returns {string}
*/
function string_reverse(s) {/** @type {string} */
const res = new string(new string(""));
res.str = [...s.str].reverse().join('')
return res;
}

/**
 * @function
 * @param {string} cutset
 * @returns {string}
*/
function string_trim(s, cutset) {if ((new bool( new bool(s.len.valueOf() < new int(1).valueOf()).valueOf() || new bool(cutset.len.valueOf() < new int(1).valueOf()).valueOf())).valueOf()) {
return string_clone(s,);
}
/** @type {int} */
let pos_left = new int(new int(0));
/** @type {int} */
let pos_right = new int(new int( s.len.valueOf() - new int(1).valueOf()));
/** @type {bool} */
let cs_match = new bool(new bool(true));
while (+new bool( new bool( new bool(pos_left.valueOf() <= s.len.valueOf()).valueOf() && new bool(pos_right.valueOf() >= new int(-1).valueOf()).valueOf()).valueOf() && cs_match.valueOf())) {
/** @type {bool} */
cs_match = new bool(new bool(false));
for (const cs of cutset.str.split('').map(c => new byte(c))) {
if ((new bool(new byte(s.str.charCodeAt(pos_left)).valueOf() == cs.valueOf())).valueOf()) {
pos_left.val ++;
/** @type {bool} */
cs_match = new bool(new bool(true));
break;
}
}

for (const cs of cutset.str.split('').map(c => new byte(c))) {
if ((new bool(new byte(s.str.charCodeAt(pos_right)).valueOf() == cs.valueOf())).valueOf()) {
pos_right.val --;
/** @type {bool} */
cs_match = new bool(new bool(true));
break;
}
}

if ((new bool(pos_left.valueOf() > pos_right.valueOf())).valueOf()) {
return new string("");
}
}

return string_substr(s,pos_left, new int( pos_right.valueOf() + new int(1).valueOf()));
}

/**
 * @function
 * @param {string} sep
 * @returns {string}
*/
function Array_string_join(s, sep) {/** @type {string} */
let res = new string(new string(""));
for (const [i, str] of s.entries()) {
/** @type {string} */
res.str = res + new string(str);
if ((new bool(i.valueOf() != new int( s.len.valueOf() - new int(1).valueOf()).valueOf())).valueOf()) {
/** @type {string} */
res.str = res + new string(sep);
}
}

return res;
}

Object.defineProperty(string.prototype,"len", { get: function() {return new int(new TextEncoder().encode(this.str).length);}, set: function(l) {/* ignore */ } });
/**
 * @function
 * @param {string} search
 * @returns {int}
*/
function string_index(s, search) {/** @type {int} */
const res = new int(new int(0));
res.val = s.str.indexOf(search)
if ((new bool(res.valueOf() == new int(-1).valueOf())).valueOf()) {
return new Option({ state:  new byte(2),err: none__});
}
const _tmp6 = new Option({});
_tmp6.data = res
return _tmp6;}

/** @namespace builtin */
/**
 * @function
 * @param {string} s
 * @returns {int}
*/
function utf8_str_visible_length(s) {/** @type {int} */
const res = new int(new int(0));
res.val = s.str.length;
return res;
}

/**
 * @function
 * @param {string} s
 * @returns {int}
*/
function utf8_str_len(s) {return s.len;
}

/** @namespace main */
/** @enum {number} */
const main__Dir = {
	up: 0,
	down: 1,
	north: 2,
	west: 3,
	south: 6,
	east: 7,
	unknown: 8,
	k: 9,
};

/* program entry point */
function js_main() {/** @type {main__Dir} */
const a = main__Dir.up;
let _tmp7 = undefined;
switch (main__Dir.k) {
	case main__Dir.up: 
	case main__Dir.unknown: 
		{
			_tmp7 = new int(1);
			
		} break;
	case main__Dir.down: 
		{
			_tmp7 = new int(2);
			
		} break;
	case main__Dir.north: 
		{
			_tmp7 = new int(2);
			
		} break;
	case main__Dir.west: 
		{
			_tmp7 = new int(main__Dir.west);
			
		} break;
	default:
		if ((main__Dir.k >= new int(4) && main__Dir.k <= new int(5)) || main__Dir.k == (main__Dir.k)) {
			_tmp7 = new int(4);
			
		}
		{
			_tmp7 = new int(3);
			
		} break;
}
/** @type {int} */
const b = new int(_tmp7);
builtin__println (int_str(b));
}

None__.prototype.str = function() {
	return None___str(this)
}
// Initializations for module strings
// Initializations for module builtin
// Initializations for module main
loadRoutine().then(_ => js_main());