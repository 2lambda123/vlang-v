module js

import (
	strings
	v.ast
	v.table
	v.depgraph
	v.token
	v.pref
	term
	v.util
)

const (
	//TODO
	js_reserved = ['delete', 'const', 'let', 'var', 'function', 'continue', 'break', 'switch', 'for', 'in', 'of', 'instanceof', 'typeof']
)

struct JsGen {
	out   			strings.Builder
	table 			&table.Table
	definitions 	strings.Builder // typedefs, defines etc (everything that goes to the top of the file)
	pref            &pref.Preferences
	mut:
	indent			int
	stmt_start_pos	int
	fn_decl			&ast.FnDecl // pointer to the FnDecl we are currently inside otherwise 0
	str_types		[]string // types that need automatic str() generation
}

pub fn gen(files []ast.File, table &table.Table, pref &pref.Preferences) string {
	mut g := JsGen{
		out: strings.new_builder(100)
		definitions: strings.new_builder(100)
		table: table
		pref: pref
		indent: -1
		fn_decl: 0
	}
	g.init()

	for file in files {
		g.stmts(file.stmts)
	}

	return g.hashes() + g.definitions.str() + g.out.str()
}

pub fn (g mut JsGen) init() {
	g.definitions.writeln('// Generated by the V compiler')
}

pub fn (g JsGen) hashes() string {
	res := '// V_COMMIT_HASH ${util.vhash()}\n'
	res += '// V_CURRENT_COMMIT_HASH ${util.githash(g.pref.building_v)}\n\n'
	return res
}


// V type to JS type
pub fn (g mut JsGen) typ(t table.Type) string {
	nr_muls := table.type_nr_muls(t)
	sym := g.table.get_type_symbol(t)
	mut styp := sym.name.replace('.', '__')
	if styp.starts_with('JS__') {
		styp = styp[4..]
	}
	match styp {
		'int' {
			styp = 'number'
		}
		'bool' {
			styp = 'boolean'
		} else {}
	}
	return styp
}

pub fn (g &JsGen) save() {}

pub fn (g mut JsGen) write(s string) {
	g.out.write(s)
}

pub fn (g mut JsGen) writeln(s string) {
	g.out.writeln(s)
}

fn (g mut JsGen) stmts(stmts []ast.Stmt) {
	g.indent++
	for stmt in stmts {
		g.stmt(stmt)
	}
	g.indent--
}

fn (g mut JsGen) stmt(node ast.Stmt) {
	g.stmt_start_pos = g.out.len

	match node {
		ast.FnDecl {
			g.fn_decl = it
			g.gen_fn_decl(it)
			g.writeln('')
		}
		ast.Return {
			g.gen_return_stmt(it)
		}
		ast.AssignStmt {
			if it.left.len > it.right.len {}
			// TODO: multi return
			else {
				for i, ident in it.left {
					var_info := ident.var_info()
					var_type_sym := g.table.get_type_symbol(var_info.typ)
					val := it.right[i]
					g.write('var /* $var_type_sym.name */ $ident.name = ')
					g.expr(val)
					g.writeln(';')
				}
			}
		}
		ast.ForStmt {
			g.write('while (')
			g.expr(it.cond)
			g.writeln(') {')
			for stmt in it.stmts {
				g.stmt(stmt)
			}
			g.writeln('}')
		}
		ast.StructDecl {
			g.writeln('class $it.name {')
			for field in it.fields {
				typ := g.typ(field.typ)
				g.writeln('\t/**')
				g.writeln('\t* @type {$typ} - ${field.name}') // the type
				g.writeln('\t*/')
				g.write('\t')
				g.write(field.name) // field name
				g.write(' = ') // seperator
				g.write('undefined;') //TODO default value for type
				g.write('\n')
			}
			g.writeln('}')
			g.writeln('')
		}
		ast.ExprStmt {
			g.expr(it.expr)
		}
		/*
			match it.expr {
				// no ; after an if expression
				ast.IfExpr {}
				else {
					g.writeln(';')
				}
	}
	*/

		else {
			verror('jsgen.stmt(): bad node')
		}
	}
}

fn (g mut JsGen) expr(node ast.Expr) {
	// println('cgen expr()')
	match node {
		ast.IntegerLiteral {
			g.write(it.val)
		}
		ast.FloatLiteral {
			g.write(it.val)
		}
		/*
		ast.UnaryExpr {
			g.expr(it.left)
			g.write(' $it.op ')
		}
		*/

		ast.StringLiteral {
			g.write('tos3("$it.val")')
		}
		ast.StringInterLiteral {
			g.gen_string_inter_literal(it)
		}
		ast.InfixExpr {
			g.expr(it.left)
			g.write(' $it.op.str() ')
			g.expr(it.right)
		}
		// `user := User{name: 'Bob'}`
		ast.StructInit {
			type_sym := g.table.get_type_symbol(it.typ)
			g.writeln('/*$type_sym.name*/{')
			for i, field in it.fields {
				g.write('\t$field : ')
				g.expr(it.exprs[i])
				g.writeln(', ')
			}
			g.write('}')
		}
		ast.CallExpr {
			g.write('${it.name}(')
			for i, arg in it.args {
				g.expr(arg.expr)
				if i != it.args.len - 1 {
					g.write(', ')
				}
			}
			g.write(')')
		}
		ast.Ident {
			g.write('$it.name')
		}
		ast.BoolLiteral {
			if it.val == true {
				g.write('true')
			}
			else {
				g.write('false')
			}
		}
		ast.IfExpr {
			for i, branch in it.branches {
				if i == 0 {
					g.write('if (')
					g.expr(branch.cond)
					g.writeln(') {')
				}
				else if i < it.branches.len-1 || !it.has_else {
					g.write('else if (')
					g.expr(branch.cond)
					g.writeln(') {')
				}
				else {
					g.write('else {')
				}
				g.stmts(branch.stmts)
				g.writeln('}')
			}
		}
		else {
			println(term.red('jsgen.expr(): bad node'))
		}
	}
}

fn (g mut JsGen) gen_string_inter_literal(it ast.StringInterLiteral) {
	g.write('tos3(`')
	for i, val in it.vals {
		escaped_val := val.replace_each(['`', '\`', '\r\n', '\n'])
		g.write(escaped_val)
		if i >= it.exprs.len {
			continue
		}
		expr := it.exprs[i]
		sfmt := it.expr_fmts[i]
		g.write('\${')
		if sfmt.len > 0 {
			fspec := sfmt[sfmt.len - 1]
			if fspec == `s` && it.expr_types[i] == table.string_type {
				g.expr(expr)
				g.write('.str')
			} else {
				g.expr(expr)
			}
		} else if it.expr_types[i] == table.string_type {
			// `name.str`
			g.expr(expr)
			g.write('.str')
		} else if it.expr_types[i] == table.bool_type {
			// `expr ? "true" : "false"`
			g.expr(expr)
			g.write(' ? "true" : "false"')
		}  else {
			sym := g.table.get_type_symbol(it.expr_types[i])
			if sym.kind == .enum_ {
				is_var := match it.exprs[i] {
					ast.SelectorExpr {
						true
					}
					ast.Ident {
						true
					}
					else {
						false
					}
				}
				if is_var {
					styp := g.typ(it.expr_types[i])
					g.gen_str_for_type(sym, styp)
					g.write('${styp}_str(')
					g.enum_expr(expr)
					g.write(').str')
				} else {
					g.write('"')
					g.enum_expr(expr)
					g.write('"')
				}
			} else {
				g.expr(expr)
			}
		}
		g.write('}')
	}
	g.write('`)')
}

fn (g mut JsGen) gen_fn_decl(it ast.FnDecl) {
	if it.no_body {
		return
	}

	is_main := it.name == 'main'
	if is_main {
		// there is no concept of main in JS but we do have iife
		g.writeln('/* program entry point */')
		g.write('(function(')
	} else {
		mut name := it.name
		c := name[0]
		if c in [`+`, `-`, `*`, `/`] {
			name = util.replace_op(name)
		}

		type_name := g.typ(it.return_type)

		// generate jsdoc for the function
		g.writeln('/**')
		for i, arg in it.args {
			arg_type_name := g.typ(arg.typ)
			is_varg := i == it.args.len - 1 && it.is_variadic
			if is_varg {
				g.writeln('* @param {...$arg_type_name} $arg.name')
			} else {
				g.writeln('* @param {$arg_type_name} $arg.name')
			}
		}
		g.writeln('* @return {$type_name}')
		g.writeln('*/')


		if it.is_method {
			// javascript has class methods, so we just assign this function on the class prototype
			className :=  g.table.get_type_symbol(it.receiver.typ).name
			g.write('${className}.prototype.${name} = ')
		}
		g.write('function ${name}(')
	}
	g.fn_args(it.args, it.is_variadic)
	g.writeln(') {')

	if is_main {
		g.writeln('\t_vinit();')
	}

	g.stmts(it.stmts)
	g.writeln('}')
	if is_main {
		g.writeln(')();')
	}
	g.fn_decl = 0
}

fn (g mut JsGen) fn_args(args []table.Arg, is_variadic bool) {
	no_names := args.len > 0 && args[0].name == 'arg_1'
	for i, arg in args {
		is_varg := i == args.len - 1 && is_variadic
		if is_varg {
			g.write('...$arg.name')
		} else {
			g.write(arg.name)
		}
		// if its not the last argument
		if i < args.len - 1 {
			g.write(', ')
		}
	}
}

fn (g mut JsGen) gen_return_stmt(it ast.Return) {
	g.write('return ')

	if g.fn_decl.name == 'main' {
		// we can't return anything in main
		g.writeln('void;')
		return
	}

	// multiple returns
	if it.exprs.len > 1 {
		g.write('[')
		for i, expr in it.exprs {
			g.expr(expr)
			if i < it.exprs.len - 1 {
				g.write(', ')
			}
		}
		g.write(']')
	}
	else {
		g.expr(it.exprs[0])
	}
	g.writeln(';')
}

fn (g mut JsGen) enum_expr(node ast.Expr) {
	match node {
		ast.EnumVal {
			g.write(it.val)
		}
		else {
			g.expr(node)
		}
	}
}

fn (g JsGen) type_to_fmt(typ table.Type) string {
	sym := g.table.get_type_symbol(typ)
	if sym.kind == .struct_ {
		return '%.*s'
	} else if typ == table.string_type {
		return "\'%.*s\'"
	} else if typ == table.bool_type {
		return '%.*s'
	} else if typ in [table.f32_type, table.f64_type] {
		return '%g'		// g removes trailing zeros unlike %f
	}
	return '%d'
}

fn verror(s string) {
	util.verror('jsgen error', s)
}
