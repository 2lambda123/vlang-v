struct AA {
	a int = 22
	b i64
}

pub fn zeroed() {
	_ := AA{}
}

pub fn field() {
	_ := AA{a: 23}
}

pub fn selector(input int) int {
	mut a := AA{}
	
	c := 10 + a.a
	
	return c
}

pub fn reassign(input int) int {
	mut a := AA{}

	a = AA{b: input}
	
	return int(a.b + input)
}

struct BB {
mut:
	a i64 = 22
	b i64
	c i64
}

pub fn give(val int) int {

	mut a := BB{}

	a.b = val
	
	return take(a)
}

pub fn take(input BB) int {
	return int(input.b)
}

struct NBB {
mut:
	a i64 = 22
	b NAA
}

struct NAA {
mut:
	a i64 = 91
	b i64 = 92
	c i64 = 93
}

pub fn make(nval NAA) i64 {
	val := NBB{b: nval}

	return val.b.b
}

pub fn reassign(nval int) int {
	val := make(NAA{b: nval})
	return int(val)
}

fn my_func(val int) NAA {
	return NAA{b: val}
}

fn accept() {
	my_func(20)
}