module eval

import v.ast

const empty = Void{}

const none_ = None{}

// Note: i64 is an int_literal, NOT an i64 (same with f64)
type Object = Array
	| Chan
	| Float
	| Int
	| None
	| Ptr
	| Thread
	| Uint
	| Void
	| []Object
	| bool
	| char
	| f64
	| i64
	| rune
	| string
	| u8
	| voidptr

pub fn (o Object) v_type_name() string {
	match o {
		[]Object {
			mut res := '('
			for i, obj in o {
				res += obj.v_type_name()
				if i + 1 != o.len {
					res += ', '
				}
			}
			return res + ')'
		}
		Array, None, Chan, Thread {
			return global_table.type_to_str(o.typ)
		}
		Void {
			return 'void'
		}
		Int {
			return 'i${o.size}'
		}
		Float {
			return 'f${o.size}'
		}
		bool {
			return 'bool'
		}
		char {
			return 'char'
		}
		i64 {
			return 'int_literal'
		}
		f64 {
			return 'float_literal'
		}
		rune {
			return 'rune'
		}
		string {
			return 'string'
		}
		u8 {
			return 'u8'
		}
		voidptr {
			return 'voidptr'
		}
		else {
			return '<unknown-type-name>'
		}
	}
}

// string is the same as the autogenerated str() methods
pub fn (o Object) string() string {
	match o {
		u8 {
			panic('error: byte should only be used for &byte')
		}
		bool {
			return o.str()
		}
		i64 { // int_literal
			return o.str()
		}
		f64 { // float_literal
			return o.str()
		}
		Int {
			return o.val.str()
		}
		Uint {
			return o.val.str()
		}
		Float {
			return o.val.str()
		}
		string {
			return o
		}
		Void {
			return ''
		}
		None {
			return 'none'
		}
		[]Object {
			mut res := '('
			for i, obj in o {
				res += obj.str()
				if i + 1 != o.len {
					res += ', '
				}
			}
			return res + ')'
		}
		voidptr {
			return o.str()
		}
		char {
			return int(o).str()
		}
		rune {
			return o.str()
		}
		Array {
			mut res := '['
			for i, val in o.val {
				res += val.string()
				if i + 1 != o.val.len {
					res += ', '
				}
			}
			res += ']'
			if o.is_fixed {
				res += '!'
			}
			return res
		}
		Ptr {
			if o.val == unsafe { nil } {
				return '&nil'
			}
			return o.val.str()
		}
		Chan {
			return '${global_table.type_to_str(o.typ)}{cap: ${o.val.cap}, closed: ${int(o.val.closed)}}'
		}
		Thread {
			return global_table.type_to_str(o.typ).replace(' ', '(') + ')'
		}
	}
}

pub fn (o Object) int_val() i64 {
	match o {
		Int {
			return o.val
		}
		Uint {
			return i64(o.val)
		}
		i64 {
			return o
		}
		else {
			panic('Object.int_val(): not an int')
		}
	}
}

pub fn (o Object) float_val() f64 {
	match o {
		Float {
			return o.val
		}
		f64 {
			return o
		}
		else {
			panic('Object.float_val(): not a float')
		}
	}
}

fn (o Object) as_i64() !i64 {
	match o {
		i64 {
			return o
		}
		Int {
			return o.val
		}
		else {
			return error('cannot cast object to i64')
		}
	}
}

struct Void {}

struct Chan {
pub mut:
	val chan Object
pub:
	typ ast.Type
}

struct Thread {
pub mut:
	val thread Object
pub:
	typ ast.Type
}

struct None {
pub:
	typ ast.Type
}

pub struct Int {
pub mut:
	val  i64
	size i8 // 8/16/32/64
}

pub struct Uint {
pub mut:
	val  u64
	size i8 // 8/16/32/64
}

pub struct Float {
pub mut:
	val  f64
	size i8 // 8/16/32/64
}

pub struct Array {
pub:
	is_fixed bool
	typ      ast.Type
pub mut:
	val []Object
}

pub struct Ptr {
	val &Object = unsafe { nil }
	typ ast.Type
}

// override the autogenerated str, since it does not work
fn (p Ptr) str() string {
	return u64(p.val).str()
}
